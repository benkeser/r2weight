% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/r2.varImport.R
\name{r2.varImp}
\alias{r2.varImp}
\title{r2.varImp}
\usage{
r2.varImp(optWeightObject, r2.optWeightObject, Y, X, verbose = FALSE,
  grpX = split(colnames(X), colnames(X)), comparison = c("diff", "ratio"),
  parallel = FALSE, n.cores = detectCores(), seed = 12345, alpha = 0.05,
  ...)
}
\arguments{
\item{Y}{The \code{data.frame} of outcomes that was used to fit \code{object}}

\item{X}{The \code{data.frame} of predictors that was used to fit \code{object}}

\item{verbose}{A \code{boolean} indicating whether to show a progress bar}

\item{grpX}{A \code{list} where each entry is a \code{vector} of \code{charater}s 
indicating groups of columns of \code{X} to remove to test their importance. Defaults to
a list of \code{colnames(X)}.}

\item{comparison}{What type of comparison should be made. Possible choices include
\code{"diff"} and \code{"ratio"}.}

\item{parallel}{A \code{boolean} indicating whether to run the CV.SuperLearner calls
in parallel using \code{mclapply}. Be sure to set options()$mc.cores to}

\item{n.cores}{A \code{numeric} indicating how many cores to use if \code{parallel = TRUE}. 
By default will use \code{detectCores()}.}

\item{seed}{The seed to set before each internal call to \code{CV.SuperLearner}}

\item{alpha}{The function returns a \code{(1-\alpha)*100}% confidence interval. Default
is set to \code{0.05} (i.e., 95% confidence interval)}

\item{object}{An \code{r2.optWeight} object.}
}
\description{
Compute variable importance for different groups of variables by
comparing the R-squared for the optimally combined outcome.
}
\examples{
X <- data.frame(x1=runif(n=100,0,5), x2=runif(n=100,0,5))
Y1 <- rnorm(100, X$x1 + X$x2, 1)
Y2 <- rnorm(100, X$x1 + X$x2, 3)
Y <- data.frame(Y1 = Y1, Y2 = Y2)
fit <- optWeight(Y = Y, X = X, SL.library = c("SL.glm","SL.mean"), family = gaussian(),outerV = 10, return.CV.SuperLearner = FALSE)
perf.fit <- r2.optWeight(object = fit, Y = Y, X = X, evalV = 5)
varImp <- r2.varImp(fit, perf.fit, Y = Y, X = X, verbose = TRUE)
}

